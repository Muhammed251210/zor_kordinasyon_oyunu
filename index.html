<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>N√∂ro Senkron 2.2</title>
    <style>
        /* --- TEMEL AYARLAR --- */
        html, body {
            margin: 0; padding: 0;
            background-color: #050505; color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; height: 100%; width: 100%;
            touch-action: none; user-select: none;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
        }

        #gameContainer {
            position: relative; width: 100%; height: 100%;
            background: #000; overflow: hidden;
        }

        .pseudo-fullscreen {
            position: fixed !important; top: 0; left: 0; right: 0; bottom: 0;
            width: 100vw !important; height: 100vh !important;
            z-index: 99999; background: #000; margin: 0; padding: 0;
        }

        canvas {
            display: block; background: transparent; width: 100%; height: 100%;
            object-fit: contain; position: absolute; top: 0; left: 0;
        }

        /* --- UI KATMANLARI --- */
        #uiLayer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; align-items: center;
            z-index: 10;
        }

        #scoreWrapper { margin-top: 20px; text-align: center; }
        #scoreDisplay {
            font-size: 5vh; font-weight: 900; text-shadow: 0 0 10px rgba(255,255,255,0.5);
            transition: transform 0.1s;
        }
        #comboDisplay {
            font-size: 3vh; color: #ffeb3b; font-weight: bold; opacity: 0; transition: opacity 0.3s;
            text-shadow: 0 0 10px #ffeb3b;
        }
        
        /* CAN G√ñSTERGESƒ∞ */
        #livesDisplay {
            margin-top: 10px; font-size: 3vh; letter-spacing: 5px;
            text-shadow: 0 0 10px #ff0000;
        }

        #gamepadStatus {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 255, 0, 0.2); border: 1px solid #00ff00; color: #00ff00;
            padding: 8px 15px; border-radius: 20px; font-weight: bold; font-size: 0.8rem;
            display: none; animation: fadeIn 0.5s; z-index: 60; backdrop-filter: blur(2px);
        }

        #fullscreenBtn, #pauseBtn, #homeBtn {
            position: absolute; top: 20px;
            background: rgba(255, 255, 255, 0.15); border: 2px solid rgba(255, 255, 255, 0.4);
            color: white; border-radius: 12px; cursor: pointer; z-index: 50;
            display: flex; justify-content: center; align-items: center;
            pointer-events: auto; transition: all 0.2s; backdrop-filter: blur(4px);
            width: 50px; height: 50px; font-size: 24px;
        }

        #fullscreenBtn:hover, #pauseBtn:hover, #homeBtn:hover { background: rgba(255, 255, 255, 0.4); transform: scale(1.1); }
        #pauseBtn { left: 20px; }
        #homeBtn { right: 20px; font-size: 28px; padding-bottom: 5px; }
        #fullscreenBtn { right: 85px; }

        /* --- MEN√úLER --- */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            pointer-events: auto; backdrop-filter: blur(8px); z-index: 40; text-align: center;
        }

        h1 {
            font-size: clamp(2rem, 5vw, 4rem); margin: 0 0 20px 0;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 30px rgba(255,255,255,0.2);
        }

        .menu-btn {
            padding: 15px 40px; font-size: 1.2rem; background: transparent;
            color: #fff; border: 3px solid #fff; border-radius: 50px;
            cursor: pointer; font-weight: bold; margin: 10px; transition: all 0.2s;
            min-width: 250px; position: relative; overflow: hidden;
        }
        .menu-btn:hover, .menu-btn.selected {
            background: #fff; color: #000; transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255,255,255,0.6);
        }

        /* --- RENK SE√áƒ∞Mƒ∞ --- */
        .color-grid {
            display: flex; justify-content: center; gap: 20px; margin-top: 30px;
            flex-wrap: wrap; max-width: 800px;
        }
        .color-btn {
            width: 70px; height: 70px; border-radius: 50%; border: 5px solid transparent;
            cursor: pointer; transition: transform 0.2s; box-sizing: border-box;
            display: flex; justify-content: center; align-items: center;
            font-size: 20px; font-weight: bold; color: rgba(0,0,0,0.5);
        }
        .color-btn.focused { transform: scale(1.3); border-color: #fff; box-shadow: 0 0 30px rgba(255,255,255,0.9); z-index: 2; color: #000; }
        .color-taken { opacity: 0.2; filter: grayscale(100%); transform: scale(0.8); }

        /* --- KONTROLLER --- */
        #controlsWrapper {
            position: absolute; bottom: 0; left: 0; width: 100%;
            padding-bottom: 20px; pointer-events: none; z-index: 30;
            display: flex; justify-content: space-between; padding-left: 20px; padding-right: 20px; box-sizing: border-box;
        }
        .control-group { display: flex; gap: 10px; pointer-events: auto; align-items: flex-end; }
        .portrait-mode-controls { justify-content: center !important; width: 100%; }

        .btn {
            width: 70px; height: 70px;
            background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 18px; display: flex; justify-content: center; align-items: center;
            font-size: 28px; color: white; cursor: pointer; backdrop-filter: blur(4px);
            transition: background 0.1s; touch-action: none;
        }
        .btn:active, .btn.active { background: rgba(255, 255, 255, 0.4); transform: scale(0.95); }
        .btn-fire { border-width: 3px; font-weight: bold; }

        .hidden { display: none !important; }
        #divider {
            position: absolute; left: 50%; top: 0; bottom: 0; width: 2px;
            background: rgba(255,255,255,0.2); transform: translateX(-50%); transition: opacity 0.5s;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, -10px); } to { opacity: 1; transform: translate(-50%, 0); } }
        
        #pauseOverlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 3rem; font-weight: bold; text-shadow: 0 0 20px cyan;
            pointer-events: none; z-index: 100; display: none;
        }
    </style>
</head>
<body>

    <div id="gameContainer">
        <canvas id="bgCanvas" style="z-index: 1;"></canvas>
        <canvas id="gameCanvas" style="z-index: 2;"></canvas>
        <div id="divider" style="z-index: 3;"></div>
        
        <div id="gamepadStatus">üéÆ GAMEPAD AKTƒ∞F</div>
        <div id="pauseOverlay">DURAKLATILDI</div>

        <button id="pauseBtn" title="Durdur">‚ùö‚ùö</button>
        <button id="fullscreenBtn" title="Tam Ekran">‚õ∂</button>
        <button id="homeBtn" title="Ana Men√º">‚åÇ</button>
        
        <div id="uiLayer">
            <div id="scoreWrapper">
                <div id="scoreDisplay">0</div>
                <div id="livesDisplay">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                <div id="comboDisplay">x1 COMBO!</div>
            </div>
        </div>

        <div id="controlsWrapper">
            <div class="control-group left-group" id="leftControls">
                <div class="btn" data-key="z">‚óÄ</div>
                <div class="btn btn-fire" data-key="x">‚óè</div>
                <div class="btn" data-key="c">‚ñ∂</div>
            </div>
            <div class="control-group right-group" id="rightControls">
                <div class="btn" data-key="ArrowLeft">‚óÄ</div>
                <div class="btn btn-fire" data-key="ArrowDown">‚óè</div>
                <div class="btn" data-key="ArrowRight">‚ñ∂</div>
            </div>
        </div>

        <!-- EKRANLAR -->
        <div id="modeScreen" class="screen">
            <h1>N√∂ro Senkron <span style="font-size:0.5em; color:cyan; vertical-align: super;">2.2</span></h1>
            <button class="menu-btn selected" id="btnMode1" onclick="selectMode(1)">1 OYUNCU<br><span style="font-size:0.6em;">Tek Ekran</span></button>
            <button class="menu-btn" id="btnMode2" onclick="selectMode(2)">2 OYUNCU<br><span style="font-size:0.6em;">B√∂l√ºnm√º≈ü Ekran</span></button>
            <div style="margin-top:20px; color:#888; font-size:0.9em;">Gamepad: Y√∂n Tu≈ülarƒ± ile Se√ß, <b>X</b> ile Onayla</div>
        </div>

        <div id="colorScreen" class="screen hidden">
            <h1 id="colorTitle">Renk Se√ß</h1>
            <div class="color-grid" id="colorGrid"></div>
            <div style="margin-top: 30px; margin-bottom: 20px; color: #ccc; font-size: 0.9em;">(√ñnce Rengi Se√ß, Sonra Onayla)</div>
            <button class="menu-btn" id="btnColorConfirm" onclick="confirmColorSelection()">ONAYLA & DEVAM ET</button>
        </div>

        <div id="startScreen" class="screen hidden">
            <h1 id="readyTitle">HAZIR MISIN?</h1>
            <div class="legend" style="display:flex; gap:20px; margin-bottom:20px; flex-wrap:wrap; justify-content:center;">
                <div style="color:#fff;">üõ°Ô∏è Kalkan</div>
                <div style="color:#ffd700;">‚è≥ Yava≈ülat</div>
            </div>
            <p id="modeHint" style="color:#aaa; font-size:1.2rem; margin-bottom:20px;"></p>
            <button class="menu-btn selected" id="startBtn">BA≈ûLA</button>
        </div>

        <div id="gameOverScreen" class="screen hidden">
            <h1 style="color: #ff3333;">OYUN Bƒ∞TTƒ∞</h1>
            <p style="font-size: 2rem;">Skor: <span id="finalScore" style="color: yellow;">0</span></p>
            <p style="font-size: 1.2rem; color:#ccc;">Maksimum Kombo: <span id="finalCombo" style="color: cyan;">x0</span></p>
            <button class="menu-btn selected" id="restartBtn">ANA MEN√ú</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const bgCanvas = document.getElementById('bgCanvas');
        const bgCtx = bgCanvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        
        // Referanslar
        const modeScreen = document.getElementById('modeScreen');
        const colorScreen = document.getElementById('colorScreen');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const livesDisplay = document.getElementById('livesDisplay');
        const comboDisplay = document.getElementById('comboDisplay');
        const finalScoreEl = document.getElementById('finalScore');
        const finalComboEl = document.getElementById('finalCombo');
        const pauseBtn = document.getElementById('pauseBtn');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const homeBtn = document.getElementById('homeBtn');
        const divider = document.getElementById('divider');
        const gamepadStatus = document.getElementById('gamepadStatus');
        const controlsWrapper = document.getElementById('controlsWrapper');
        const rightControls = document.getElementById('rightControls');
        const btnColorConfirm = document.getElementById('btnColorConfirm');

        let gameMode = 1; 
        let currentPlayerSelecting = 1;
        let isPlaying = false; isPaused = false;
        let score = 0; let combo = 1; let maxCombo = 1; let lives = 3;
        let speed = 5; let baseSpeed = 5;
        let animationId; let frames = 0;
        let isPseudoFullscreen = false; let isPortrait = false;
        let shakeIntensity = 0; let globalSlowMo = 1.0; let slowMoTimer = 0;

        let menuIndex = 0; 
        let selectedColorIndex = 0;
        let lastGamepadInputTime = 0; 

        const colors = ['#00ffff', '#ff00ff', '#00ff00', '#ffff00', '#ff3300', '#aa00ff', '#ffffff', '#0099ff'];
        const playerSize = 30;
        const player1 = { x: 0, y: 0, color: '#00ffff', trail: [], lastShot: 0, shieldTimer: 0, invulnerable: 0 };
        const player2 = { x: 0, y: 0, color: '#ff00ff', trail: [], lastShot: 0, shieldTimer: 0, invulnerable: 0 };

        let obstacles = []; let particles = []; let bullets = []; let powerups = []; let backgroundStars = []; let floatingTexts = [];

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);

            if (type === 'hurt') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, t); osc.frequency.exponentialRampToValueAtTime(50, t + 0.4);
                gain.gain.setValueAtTime(0.3, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
                osc.start(t); osc.stop(t + 0.4);
            } else if (type === 'click' || type === 'menu_move') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(600, t); gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1); osc.start(t); osc.stop(t + 0.1);
            } else if (type === 'select') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(400, t); osc.frequency.linearRampToValueAtTime(800, t+0.1); gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1); osc.start(t); osc.stop(t + 0.1);
            } else if (type === 'shoot') {
                osc.type = 'square'; osc.frequency.setValueAtTime(800, t); osc.frequency.exponentialRampToValueAtTime(100, t + 0.15); gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15); osc.start(t); osc.stop(t + 0.15);
            } else if (type === 'explosion') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, t); osc.frequency.exponentialRampToValueAtTime(10, t + 0.3); gain.gain.setValueAtTime(0.2, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3); osc.start(t); osc.stop(t + 0.3);
            } else if (type === 'powerup') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(600, t); osc.frequency.linearRampToValueAtTime(1200, t+0.2); gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2); osc.start(t); osc.stop(t + 0.2);
            } else if (type === 'combo') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(800 + (combo*50), t); gain.gain.setValueAtTime(0.05, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1); osc.start(t); osc.stop(t + 0.1);
            } else if (type === 'armor') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, t); gain.gain.setValueAtTime(0.2, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1); osc.start(t); osc.stop(t + 0.1);
            }
        }

        function initStars() {
            backgroundStars = [];
            for(let i=0; i<100; i++) {
                backgroundStars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 2, speed: Math.random() * 2 + 0.5 });
            }
        }

        function drawBackground() {
            bgCtx.fillStyle = '#000'; bgCtx.fillRect(0, 0, canvas.width, canvas.height);
            let hue = (Date.now() / 50) % 360;
            if (combo > 5) bgCtx.strokeStyle = `hsla(${hue}, 100%, 50%, 0.1)`; else bgCtx.strokeStyle = 'rgba(255,255,255,0.05)';
            bgCtx.fillStyle = '#fff';
            backgroundStars.forEach(star => {
                if (isPlaying && !isPaused) star.y += star.speed * globalSlowMo * (1 + (combo/20));
                if (star.y > canvas.height) { star.y = 0; star.x = Math.random() * canvas.width; }
                bgCtx.globalAlpha = Math.random() * 0.5 + 0.3; bgCtx.fillRect(star.x, star.y, star.size, star.size);
            });
            bgCtx.globalAlpha = 1.0;
        }

        function triggerShake(intensity) { shakeIntensity = intensity; }

        // --- YENƒ∞ HASAR Sƒ∞STEMƒ∞ ---
        function takeDamage(p) {
            if (p.invulnerable > 0) return;

            lives--;
            updateLivesUI();
            score -= 50; 
            if(score < 0) score = 0;
            scoreDisplay.innerText = score;
            
            combo = 1; 
            updateComboUI();
            
            playSound('hurt');
            triggerShake(20);
            
            // G√∂rsel Geri Bildirim
            floatingTexts.push({ text: "-50", x: p.x, y: p.y - 20, color: "#ff0000", life: 1.0 });
            createParticles(p.x + playerSize/2, p.y + playerSize/2, '#ff0000');

            if (lives <= 0) {
                gameOver();
            } else {
                // √ñl√ºms√ºzl√ºk (60 frame = 1 saniye)
                player1.invulnerable = 120; 
                player2.invulnerable = 120; 
            }
        }

        function updateLivesUI() {
            let hearts = "";
            for(let i=0; i<lives; i++) hearts += "‚ù§Ô∏è";
            livesDisplay.innerText = hearts;
        }

        // ... Men√º fonksiyonlarƒ± (√∂nceki ile aynƒ±, sadece √∂zet) ...
        function updateMenuVisuals() {
            if (!modeScreen.classList.contains('hidden')) {
                document.getElementById('btnMode1').classList.toggle('selected', menuIndex === 0);
                document.getElementById('btnMode2').classList.toggle('selected', menuIndex === 1);
            }
        }

        function handleMenuInput(direction, isSelect) {
            const now = Date.now();
            if (now - lastGamepadInputTime < 200) return; 
            lastGamepadInputTime = now;

            if (!modeScreen.classList.contains('hidden')) {
                if (direction === 'down' || direction === 'right') menuIndex = 1;
                if (direction === 'up' || direction === 'left') menuIndex = 0;
                if (isSelect) selectMode(menuIndex + 1);
                else if (direction) playSound('menu_move');
                updateMenuVisuals();
            } 
            else if (!colorScreen.classList.contains('hidden')) {
                if (direction === 'right') selectedColorIndex = (selectedColorIndex + 1) % colors.length;
                if (direction === 'left') selectedColorIndex = (selectedColorIndex - 1 + colors.length) % colors.length;
                if (direction === 'down' && selectedColorIndex + 4 < colors.length) selectedColorIndex += 4;
                if (direction === 'up' && selectedColorIndex - 4 >= 0) selectedColorIndex -= 4;
                
                if (isSelect) confirmColorSelection();
                else if (direction) playSound('menu_move');
                updateColorGridVisuals();
            }
            else if (!startScreen.classList.contains('hidden')) { if (isSelect) startGame(); }
            else if (!gameOverScreen.classList.contains('hidden')) { if (isSelect) resetToMenu(); }
        }

        function selectMode(mode) {
            gameMode = mode; modeScreen.classList.add('hidden');
            currentPlayerSelecting = 1; selectedColorIndex = 0; menuIndex = 0;
            setupColorSelection(1); playSound('select');
        }

        function setupColorSelection(playerNum) {
            currentPlayerSelecting = playerNum;
            colorScreen.classList.remove('hidden');
            const title = document.getElementById('colorTitle');
            const grid = document.getElementById('colorGrid');
            grid.innerHTML = '';
            title.innerText = (gameMode === 1 || isPortrait) ? "Geminin Rengini Se√ß" : `Oyuncu ${playerNum} Rengi`;
            title.style.color = '#fff';
            btnColorConfirm.innerText = (gameMode === 2 && !isPortrait && playerNum === 1) ? "ONAYLA & SONRAKƒ∞ OYUNCU" : "ONAYLA & DEVAM ET";
            colors.forEach((c, index) => {
                const btn = document.createElement('div');
                btn.className = 'color-btn';
                btn.style.backgroundColor = c;
                btn.innerText = index + 1;
                const isTaken = (gameMode === 2 && !isPortrait && playerNum === 2 && player1.color === c);
                if (isTaken) btn.classList.add('color-taken');
                btn.onclick = () => {
                    if(isTaken) return;
                    selectedColorIndex = index;
                    updateColorGridVisuals();
                    playSound('click'); 
                };
                grid.appendChild(btn);
            });
            updateColorGridVisuals();
        }

        function updateColorGridVisuals() {
            const btns = document.querySelectorAll('.color-btn');
            btns.forEach((btn, idx) => {
                if (idx === selectedColorIndex) btn.classList.add('focused');
                else btn.classList.remove('focused');
            });
            btnColorConfirm.style.borderColor = colors[selectedColorIndex];
            btnColorConfirm.style.color = colors[selectedColorIndex];
        }

        function confirmColorSelection() {
            const chosenColor = colors[selectedColorIndex];
            if (gameMode === 2 && !isPortrait && currentPlayerSelecting === 2 && player1.color === chosenColor) return;
            playSound('select');
            if (gameMode === 1 || isPortrait) {
                player1.color = chosenColor; player2.color = chosenColor;
                finishSetup();
            } else {
                if (currentPlayerSelecting === 1) {
                    player1.color = chosenColor; currentPlayerSelecting = 2;
                    let nextIdx = 0;
                    while(colors[nextIdx] === player1.color) nextIdx++;
                    selectedColorIndex = nextIdx;
                    setupColorSelection(2);
                } else {
                    player2.color = chosenColor;
                    finishSetup();
                }
            }
        }

        function finishSetup() {
            colorScreen.classList.add('hidden');
            updateUIColors();
            const modeHint = document.getElementById('modeHint');
            if (isPortrait) modeHint.innerHTML = "Dƒ∞KEY MOD<br>Tek Kontrolc√º - T√ºm Gemileri Y√∂net";
            else if (gameMode === 1) modeHint.innerText = "1 OYUNCU: Her iki kontrol de aynƒ± gemiyi y√∂netir";
            else modeHint.innerText = "2 OYUNCU: Ekranƒ± payla≈üƒ±n, g√∂revinizi yapƒ±n";
            startScreen.classList.remove('hidden');
        }

        function updateUIColors() {
            const leftBtns = document.querySelectorAll('.left-group .btn');
            const rightBtns = document.querySelectorAll('.right-group .btn');
            const cL = player1.color;
            const cR = (gameMode === 1 || isPortrait) ? player1.color : player2.color;
            leftBtns.forEach(b => { b.style.borderColor = cL; b.style.color = cL; b.style.boxShadow = `0 0 10px ${cL}40`; if(b.classList.contains('btn-fire')) b.style.backgroundColor = `${cL}20`; });
            rightBtns.forEach(b => { b.style.borderColor = cR; b.style.color = cR; b.style.boxShadow = `0 0 10px ${cR}40`; if(b.classList.contains('btn-fire')) b.style.backgroundColor = `${cR}20`; });
            document.querySelector('#readyTitle').style.background = `linear-gradient(90deg, ${cL}, ${cR})`;
            document.querySelector('#readyTitle').style.webkitTextFillColor = 'transparent';
            document.querySelector('#readyTitle').style.webkitBackgroundClip = 'text';
        }

        function resetToMenu() {
            isPlaying = false; isPaused = false; pauseOverlay.style.display = 'none';
            gameOverScreen.classList.add('hidden'); startScreen.classList.add('hidden');
            colorScreen.classList.add('hidden'); modeScreen.classList.remove('hidden');
            divider.style.opacity = '1';
            if(isPseudoFullscreen) { gameContainer.classList.remove('pseudo-fullscreen'); isPseudoFullscreen = false; gameContainer.style.cursor = 'default'; resizeCanvas(); }
        }

        const keys = { z: false, c: false, x: false, ArrowLeft: false, ArrowRight: false, ArrowDown: false };

        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', resetToMenu);
        document.getElementById('homeBtn').addEventListener('click', resetToMenu);

        function startGame() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            isPlaying = true; isPaused = false;
            pauseBtn.innerText = '‚ùö‚ùö'; pauseOverlay.style.display = 'none';
            score = 0; combo = 1; maxCombo = 1; speed = 5; frames = 0;
            lives = 3; updateLivesUI();
            shakeIntensity = 0; globalSlowMo = 1.0;
            player1.shieldTimer = 0; player2.shieldTimer = 0;
            player1.invulnerable = 0; player2.invulnerable = 0;
            obstacles = []; particles = []; bullets = []; powerups = []; floatingTexts = [];
            resizeCanvas();
            startScreen.classList.add('hidden'); gameOverScreen.classList.add('hidden');
            scoreDisplay.innerText = "0"; comboDisplay.style.opacity = 0;
        }

        function spawnPowerup() {
            const type = Math.random() > 0.5 ? 'shield' : 'slow';
            const size = 30; const x = Math.random() * (canvas.width - size);
            powerups.push({ x: x, y: -50, w: size, h: size, type: type, speed: baseSpeed * 0.8, color: type === 'shield' ? '#00ffff' : '#ffff00' });
        }

        function gameLoop() {
            requestAnimationFrame(gameLoop);
            const gp = pollGamepads();
            if (!isPlaying || isPaused) {
                if (gp) {
                    let dir = null;
                    if (gp.left) dir = 'left'; if (gp.right) dir = 'right'; if (gp.up) dir = 'up'; if (gp.down) dir = 'down';
                    if (dir || gp.fire) handleMenuInput(dir, gp.fire); else lastGamepadInputTime = 0;
                }
                return;
            }
            update(gp); draw();
        }

        window.addEventListener("gamepadconnected", () => {
            document.getElementById('gamepadStatus').style.display = 'block';
            setTimeout(() => document.getElementById('gamepadStatus').style.display = 'none', 3000);
        });

        function pollGamepads() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            if (!gamepads[0]) return null; 
            const gp = gamepads[0]; const deadzone = 0.5;
            let left = gp.axes[0] < -deadzone || gp.buttons[14]?.pressed;
            let right = gp.axes[0] > deadzone || gp.buttons[15]?.pressed;
            let up = gp.axes[1] < -deadzone || gp.buttons[12]?.pressed;
            let down = gp.axes[1] > deadzone || gp.buttons[13]?.pressed;
            let fire = gp.buttons[0]?.pressed || gp.buttons[1]?.pressed || gp.buttons[2]?.pressed || gp.buttons[3]?.pressed;
            return { left, right, up, down, fire };
        }

        function update(gp) {
            if (slowMoTimer > 0) { globalSlowMo = 0.4; slowMoTimer--; } else { globalSlowMo = 1.0; }
            if (player1.shieldTimer > 0) player1.shieldTimer--; if (player2.shieldTimer > 0) player2.shieldTimer--;
            if (player1.invulnerable > 0) player1.invulnerable--; if (player2.invulnerable > 0) player2.invulnerable--;

            const gpInput = gp || { left: false, right: false, fire: false };
            const moveSpeed = ((canvas.width < 600) ? 6 : 9) * (globalSlowMo < 1 ? 0.8 : 1); 

            const p1L = keys.z || gpInput.left || (gameMode===1 && keys.ArrowLeft);
            const p1R = keys.c || gpInput.right || (gameMode===1 && keys.ArrowRight);
            const p1F = keys.x || gpInput.fire || (gameMode===1 && keys.ArrowDown);
            const p2L = keys.ArrowLeft; const p2R = keys.ArrowRight; const p2F = keys.ArrowDown;

            if (gameMode === 1 || isPortrait) {
                if (p1L && player1.x > 0) player1.x -= moveSpeed;
                if (p1R && player1.x < canvas.width - playerSize) player1.x += moveSpeed;
                if (p1F) fireBullet(player1, player1.x);
                if (frames % 3 === 0) { player1.trail.push({x: player1.x, y: player1.y}); if(player1.trail.length > 8) player1.trail.shift(); }
            } else {
                if (p1L && player1.x > 0) player1.x -= moveSpeed;
                if (p1R && player1.x < (canvas.width/2) - playerSize - 5) player1.x += moveSpeed;
                if (p1F) fireBullet(player1, player1.x);
                if (p2L && player2.x > (canvas.width/2) + 5) player2.x -= moveSpeed;
                if (p2R && player2.x < canvas.width - playerSize) player2.x += moveSpeed;
                if (p2F) fireBullet(player2, player2.x);
                if (frames % 3 === 0) { player1.trail.push({x: player1.x, y: player1.y}); player2.trail.push({x: player2.x, y: player2.y}); if(player1.trail.length > 8) player1.trail.shift(); if(player2.trail.length > 8) player2.trail.shift(); }
            }

            for(let i=bullets.length-1; i>=0; i--) { bullets[i].y -= 12 * globalSlowMo; if(bullets[i].y < 0) bullets.splice(i,1); }
            
            // Floating Texts Update
            for(let i=floatingTexts.length-1; i>=0; i--) {
                let ft = floatingTexts[i];
                ft.y -= 1; ft.life -= 0.02;
                if (ft.life <= 0) floatingTexts.splice(i, 1);
            }

            for(let i=powerups.length-1; i>=0; i--) {
                let p = powerups[i]; p.y += p.speed * globalSlowMo;
                let players = (gameMode === 1 || isPortrait) ? [player1] : (p.x < canvas.width/2 ? [player1] : [player2]);
                for(let ply of players) {
                    if (ply.x < p.x + p.w && ply.x + playerSize > p.x && ply.y < p.y + p.h && ply.y + playerSize > p.y) {
                        playSound('powerup'); if (p.type === 'shield') ply.shieldTimer = 300; else slowMoTimer = 300; powerups.splice(i, 1); return;
                    }
                }
                if (p.y > canvas.height) powerups.splice(i, 1);
            }

            let spawnRate = Math.max(20, 60 - Math.floor(score/100));
            if (frames % spawnRate === 0) {
                if (Math.random() < 0.05) spawnPowerup();
                const type = Math.random(); const obsSize = (canvas.width < 600) ? 30 : 40; const isArmored = Math.random() < 0.25; 
                if (gameMode === 1 || isPortrait) obstacles.push({ x: Math.random() * (canvas.width - obsSize), y: -50, w: obsSize, h: obsSize, speed: speed + Math.random(), armored: isArmored, targetColor: player1.color, side: 'all' });
                else {
                    if (type < 0.6) obstacles.push({ side: 'left', x: Math.random()*((canvas.width/2)-obsSize), y: -50, w: obsSize, h: obsSize, speed: speed+Math.random(), armored: isArmored, targetColor: player1.color });
                    if (type > 0.4) obstacles.push({ side: 'right', x: (canvas.width/2) + Math.random()*((canvas.width/2)-obsSize), y: -50, w: obsSize, h: obsSize, speed: speed+Math.random(), armored: isArmored, targetColor: player2.color });
                }
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i]; obs.y += obs.speed * globalSlowMo; let hit = false;
                for (let j = bullets.length - 1; j >= 0; j--) {
                    let b = bullets[j];
                    let canHit = (gameMode === 1 || isPortrait) || (b.side === obs.side);
                    if (canHit && b.x > obs.x && b.x < obs.x+obs.w && b.y > obs.y && b.y < obs.y+obs.h) {
                        bullets.splice(j, 1);
                        if (obs.armored) { playSound('armor'); createParticles(b.x, b.y, '#fff'); combo=1; updateComboUI(); }
                        else {
                            createParticles(obs.x+obs.w/2, obs.y+obs.h/2, obs.targetColor); triggerShake(5); obstacles.splice(i, 1); hit = true;
                            combo++; if(combo>maxCombo) maxCombo=combo; score+=10*combo; scoreDisplay.innerText=score; updateComboUI(); playSound('combo');
                        }
                        break;
                    }
                }
                if (hit) continue;
                let players = (gameMode === 1 || isPortrait) ? [player1] : (obs.side === 'left' ? [player1] : [player2]);
                for (let p of players) {
                    if (p.x < obs.x + obs.w && p.x + playerSize > obs.x && p.y < obs.y + obs.h && p.y + playerSize > obs.y) {
                        if (p.shieldTimer > 0) { obstacles.splice(i, 1); createParticles(obs.x, obs.y, '#fff'); playSound('explosion'); triggerShake(10); return; }
                        else { 
                            // Take Damage
                            takeDamage(p);
                            obstacles.splice(i, 1); // Engeli yine de sil ki anƒ±nda tekrar vurmasƒ±n
                            return; 
                        }
                    }
                }
                if (obs.y > canvas.height) {
                    obstacles.splice(i, 1); if(!obs.armored){ combo=1; updateComboUI(); } else { score+=5*combo; scoreDisplay.innerText=score; }
                    if (score % 500 === 0) speed += 0.5;
                }
            }
            for(let i=particles.length-1; i>=0; i--) { particles[i].x += particles[i].vx; particles[i].y += particles[i].vy; particles[i].life -= 0.05; if(particles[i].life <= 0) particles.splice(i, 1); }
            frames++;
        }

        function updateComboUI() {
            if (combo > 1) { comboDisplay.innerText = `x${combo} COMBO!`; comboDisplay.style.opacity = 1; comboDisplay.style.transform = "scale(1.5)"; setTimeout(() => comboDisplay.style.transform = "scale(1)", 100); } 
            else { comboDisplay.style.opacity = 0; }
        }

        function fireBullet(p, x) {
            if (Date.now() - p.lastShot > 250) {
                p.lastShot = Date.now();
                bullets.push({ x: x + playerSize/2, y: p.y, r: 4, color: p.color, side: (gameMode===2 && !isPortrait && p===player1)?'left':((gameMode===2 && !isPortrait)?'right':'all') });
                playSound('shoot');
            }
        }

        function draw() {
            if (shakeIntensity > 0) {
                let dx = (Math.random() - 0.5) * shakeIntensity; let dy = (Math.random() - 0.5) * shakeIntensity;
                ctx.setTransform(1, 0, 0, 1, dx, dy); shakeIntensity *= 0.9; if (shakeIntensity < 0.5) shakeIntensity = 0;
            } else ctx.setTransform(1, 0, 0, 1, 0, 0);

            drawBackground(); ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Floating Texts
            floatingTexts.forEach(ft => {
                ctx.globalAlpha = ft.life;
                ctx.fillStyle = ft.color;
                ctx.font = "bold 20px Arial";
                ctx.fillText(ft.text, ft.x, ft.y);
            });
            ctx.globalAlpha = 1.0;

            powerups.forEach(p => {
                ctx.shadowBlur=20; ctx.shadowColor=p.color; ctx.fillStyle=p.color; ctx.beginPath();
                if (p.type === 'shield') ctx.arc(p.x+p.w/2, p.y+p.h/2, p.w/2, 0, Math.PI*2); else ctx.fillRect(p.x, p.y, p.w, p.h);
                ctx.fill(); ctx.fillStyle='#000'; ctx.font='bold 16px Arial'; ctx.textAlign='center'; ctx.fillText(p.type==='shield'?'S':'T', p.x+p.w/2, p.y+p.h/1.5);
            });

            let players = (gameMode === 1 || isPortrait) ? [player1] : [player1, player2];
            players.forEach(p => {
                if(p.invulnerable > 0 && Math.floor(Date.now() / 100) % 2 === 0) return; // Yanƒ±p s√∂nme

                ctx.fillStyle = p.color; ctx.shadowColor = p.color; ctx.shadowBlur=15; ctx.fillRect(p.x, p.y, playerSize, playerSize);
                if (p.shieldTimer > 0) { ctx.beginPath(); ctx.arc(p.x+playerSize/2, p.y+playerSize/2, playerSize, 0, Math.PI*2); ctx.strokeStyle=`rgba(255,255,255,${Math.random()*0.5+0.5})`; ctx.lineWidth=3; ctx.stroke(); }
                ctx.shadowBlur=0; ctx.lineWidth=2; ctx.strokeStyle=p.color; ctx.beginPath(); p.trail.forEach((t,i)=>{ if(i===0)ctx.moveTo(t.x+15,t.y+15);else ctx.lineTo(t.x+15,t.y+15); }); ctx.stroke();
            });

            ctx.shadowBlur=10; bullets.forEach(b => { ctx.fillStyle=b.color; ctx.shadowColor=b.color; ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill(); });
            obstacles.forEach(o => {
                if(o.armored){ ctx.shadowBlur=0; ctx.fillStyle='#333'; ctx.strokeStyle='#aaa'; ctx.lineWidth=4; }
                else { ctx.shadowBlur=10; let c = (gameMode===1 || isPortrait) ? player1.color : (o.side==='left'?player1.color:player2.color); ctx.fillStyle=shadeColor(c,-50); ctx.shadowColor=c; ctx.strokeStyle=c; ctx.lineWidth=3; }
                ctx.fillRect(o.x, o.y, o.w, o.h); ctx.strokeRect(o.x, o.y, o.w, o.h);
            });
            ctx.shadowBlur=0; particles.forEach(p => { ctx.globalAlpha=p.life; ctx.fillStyle=p.color; ctx.fillRect(p.x, p.y, 4, 4); }); ctx.globalAlpha=1.0;
        }

        function createParticles(x,y,c) { for(let i=0;i<12;i++) particles.push({x, y, vx:(Math.random()-0.5)*12, vy:(Math.random()-0.5)*12, life:1, color:c}); }
        function shadeColor(color, percent) { return color; }

        function resizeCanvas() {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight;
            isPortrait = window.innerHeight > window.innerWidth;
            const controlHeight = isPortrait ? 150 : 100; 
            const targetY = canvas.height - controlHeight - playerSize - 20; 
            player1.y = targetY; player2.y = targetY;
            if (isPortrait) { controlsWrapper.classList.add('portrait-mode-controls'); rightControls.classList.add('hidden'); divider.style.opacity = '0'; } 
            else { controlsWrapper.classList.remove('portrait-mode-controls'); if (gameMode === 2) { rightControls.classList.remove('hidden'); divider.style.opacity = '1'; } else { rightControls.classList.remove('hidden'); divider.style.opacity = '0'; } }
        }
        window.addEventListener('resize', resizeCanvas); resizeCanvas(); initStars();

        const toggleFullscreen = () => {
            if (document.fullscreenElement) { document.exitFullscreen(); return; }
            if (isPseudoFullscreen) { gameContainer.classList.remove('pseudo-fullscreen'); isPseudoFullscreen = false; gameContainer.style.cursor = 'default'; resizeCanvas(); return; }
            const req = gameContainer.requestFullscreen || gameContainer.webkitRequestFullscreen || gameContainer.msRequestFullscreen;
            if (req) { req.call(gameContainer).catch(() => { gameContainer.classList.add('pseudo-fullscreen'); isPseudoFullscreen = true; gameContainer.style.cursor = 'none'; resizeCanvas(); }); } 
            else { gameContainer.classList.add('pseudo-fullscreen'); isPseudoFullscreen = true; gameContainer.style.cursor = 'none'; resizeCanvas(); }
        };
        fullscreenBtn.addEventListener('click', toggleFullscreen);

        function togglePause() {
            if (!isPlaying) return;
            isPaused = !isPaused; pauseBtn.innerText = isPaused ? '‚ñ∂' : '‚ùö‚ùö';
            pauseOverlay.style.display = isPaused ? 'block' : 'none';
            if(!isPaused && audioCtx.state === 'suspended') audioCtx.resume();
        }
        pauseBtn.addEventListener('click', togglePause);

        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && isPseudoFullscreen) toggleFullscreen();
            if (!isPlaying || isPaused) {
                if (e.key === 'ArrowUp') handleMenuInput('up', false);
                else if (e.key === 'ArrowDown') handleMenuInput('down', false);
                else if (e.key === 'ArrowLeft') handleMenuInput('left', false);
                else if (e.key === 'ArrowRight') handleMenuInput('right', false);
                else if (e.key === 'Enter') handleMenuInput(null, true);
                else if (e.key >= '1' && e.key <= '8' && !colorScreen.classList.contains('hidden')) {
                    const idx = parseInt(e.key) - 1; if(idx < colors.length) { selectedColorIndex = idx; updateColorGridVisuals(); }
                }
                return;
            }
            if ((e.key.toLowerCase() === 's' || e.key === 'ArrowUp') && isPlaying) { togglePause(); return; }
            if (e.key.toLowerCase() === 'z') keys.z = true; if (e.key.toLowerCase() === 'c') keys.c = true; if (e.key.toLowerCase() === 'x') keys.x = true;
            if (e.key === 'ArrowLeft') keys.ArrowLeft = true; if (e.key === 'ArrowRight') keys.ArrowRight = true; if (e.key === 'ArrowDown') keys.ArrowDown = true;
        });
        window.addEventListener('keyup', (e) => {
            if (e.key.toLowerCase() === 'z') keys.z = false; if (e.key.toLowerCase() === 'c') keys.c = false; if (e.key.toLowerCase() === 'x') keys.x = false;
            if (e.key === 'ArrowLeft') keys.ArrowLeft = false; if (e.key === 'ArrowRight') keys.ArrowRight = false; if (e.key === 'ArrowDown') keys.ArrowDown = false;
        });

        document.querySelectorAll('.btn').forEach(btn => {
            const k = btn.dataset.key;
            btn.addEventListener('touchstart', (e)=>{ e.preventDefault(); keys[k]=true; btn.classList.add('active'); if(isPlaying) playSound('click'); });
            btn.addEventListener('touchend', (e)=>{ e.preventDefault(); keys[k]=false; btn.classList.remove('active'); });
            btn.addEventListener('mousedown', ()=>{ keys[k]=true; btn.classList.add('active'); if(isPlaying) playSound('click'); });
            btn.addEventListener('mouseup', ()=>{ keys[k]=false; btn.classList.remove('active'); });
        });

        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>


